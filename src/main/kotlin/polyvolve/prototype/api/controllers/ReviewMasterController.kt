package polyvolve.prototype.api.controllers

import org.springframework.http.MediaType
import org.springframework.security.core.annotation.AuthenticationPrincipal
import org.springframework.validation.BindingResult
import org.springframework.validation.beanvalidation.SpringValidatorAdapter
import org.springframework.web.bind.annotation.*
import polyvolve.prototype.api.data.models.recentlyviewed.RecentlyViewedType
import polyvolve.prototype.api.data.models.review.Review
import polyvolve.prototype.api.data.models.review.master.IntervalType
import polyvolve.prototype.api.data.models.review.master.ReviewMaster
import polyvolve.prototype.api.data.models.review.master.StatusType
import polyvolve.prototype.api.data.models.schema.ReviewSchema
import polyvolve.prototype.api.data.models.team.Team
import polyvolve.prototype.api.data.models.user.User
import polyvolve.prototype.api.services.*
import polyvolve.prototype.api.util.OkResponseEntity
import polyvolve.prototype.api.util.defaultOkResponse
import polyvolve.prototype.api.util.validateAndThrow
import java.security.Principal
import java.util.*
import javax.validation.constraints.NotEmpty
import javax.validation.constraints.NotNull

@RestController
@RequestMapping("/review/master")
class ReviewMasterController(val reviewMasterService: ReviewMasterService,
                             val reviewSchemaService: ReviewSchemaService,
                             val adminService: AdminService,
                             val userService: UserService,
                             val recentlyViewedService: RecentlyViewedService,
                             var validator: SpringValidatorAdapter) {
    /**
     * This endpoint would normally not be used. Instead [ReviewMaster]s should be generated by this application.
     * It should only be used for debugging purposes
     */
    @PostMapping("/create", consumes = [MediaType.APPLICATION_JSON_VALUE])
    fun createReviewMaster(@RequestBody body: CreateReviewMasterForm, bindingResult: BindingResult): OkResponseEntity {
        validator.validateAndThrow(body, bindingResult)

        val schema = reviewSchemaService.getSchema(body.schemaId!!)
                ?: throw IllegalArgumentException("Unable to find schema with criterion ${body.schemaId}")

        val id = reviewMasterService.createReviewMaster(
                body.topic,
                body.dueAt!!,
                body.periodStart!!,
                body.periodEnd!!,
                "",
                body.interval!!,
                schema,
                body.intervalType)

        return defaultOkResponse(id)
    }

    @GetMapping("/scores/export/get/{reviewMasterId}")
    fun getScores(@PathVariable reviewMasterId: UUID, @AuthenticationPrincipal principal: Principal?): OkResponseEntity {
        val reviewMaster = reviewMasterService.getReviewMaster(reviewMasterId)
                ?: throw IllegalArgumentException("ReviewMaster with criterion $reviewMasterId doesn't exist")

        val scores = reviewMasterService.getScores(reviewMaster)

        return defaultOkResponse(scores)
    }

    @GetMapping("/get/{reviewMasterId}")
    fun getReviewMaster(@PathVariable reviewMasterId: UUID, @AuthenticationPrincipal principal: Principal?): OkResponseEntity {
        val reviewMaster = reviewMasterService.getReviewMaster(reviewMasterId)
                ?: throw IllegalArgumentException("ReviewMaster with criterion $reviewMasterId doesn't exist")

        val admin = adminService.retrieveAdminAndThrow(principal)
        val lastViewedItems = recentlyViewedService.getRecentForAdmin(admin)
        val itemIsAlreadyIncluded = lastViewedItems
                .find { item -> item.targetId == reviewMasterId && item.type == RecentlyViewedType.REVIEW_MASTER } != null
        if (!itemIsAlreadyIncluded) recentlyViewedService.createFrom(reviewMaster, Date(), admin)

        return defaultOkResponse(GetReviewMasterResponse(reviewMaster, reviewMaster.schema, reviewMaster.reviewedUsers, reviewMaster.teams, reviewMaster.reviews))
    }

    @PostMapping("/update", consumes = [MediaType.APPLICATION_JSON_VALUE])
    fun updateReviewMaster(@RequestBody body: UpdateReviewMasterForm, bindingResult: BindingResult): OkResponseEntity {
        validator.validateAndThrow(body, bindingResult)

        val reviewMaster = reviewMasterService.updateReviewMaster(
                body.id!!,
                body.name,
                body.description,
                body.periodStart,
                body.periodEnd,
                body.dueAt,
                body.interval,
                body.intervalType,
                body.status,
                body.userIds,
                body.teamIds)

        return defaultOkResponse(GetReviewMasterResponse(reviewMaster, reviewMaster.schema, reviewMaster.reviewedUsers, reviewMaster.teams, reviewMaster.reviews))
    }

    @GetMapping("/link/{reviewMasterId}/{userId}")
    fun getLinkForUser(@PathVariable reviewMasterId: UUID, @PathVariable userId: UUID, @AuthenticationPrincipal principal: Principal?): OkResponseEntity {
        adminService.retrieveAdminAndThrow(principal)

        val reviewMaster = reviewMasterService.getReviewMaster(reviewMasterId)
                ?: throw IllegalArgumentException("ReviewMaster with id $reviewMasterId doesn't exist")

        val user = userService.get(userId) ?: throw IllegalArgumentException("Unable to find user with userId $userId")

        val dataHash = reviewMasterService.getOrCreateDataHash(reviewMaster, user)
        return defaultOkResponse(dataHash)
    }

    @PostMapping("/triggerreminder", consumes = [MediaType.APPLICATION_JSON_VALUE])
    fun triggerReminder(@RequestBody body: TriggerReminderForm, @AuthenticationPrincipal principal: Principal?): OkResponseEntity {
        val admin = adminService.retrieveAdminAndThrow(principal)


        val reviewMaster = reviewMasterService.getReviewMaster(body.id!!)
                ?: throw IllegalArgumentException("ReviewMaster with criterion ${body.id} doesn't exist")

        val user = if (body.userId != null) {
            userService.get(body.userId!!)
                    ?: throw IllegalArgumentException("Unable to find user with criterion ${body.userId}")
        } else null

        reviewMasterService.triggerReminder(reviewMaster, admin, user)

        return defaultOkResponse(reviewMaster)
    }

    @GetMapping("/all")
    fun getAllMasters(): OkResponseEntity {
        return defaultOkResponse(reviewMasterService.getAllReviewMasters())
    }

    class CreateReviewMasterForm {
        @field:NotEmpty
        var topic = ""

        @field:NotNull
        var periodStart: Date? = null

        @field:NotNull
        var periodEnd: Date? = null

        @field:NotNull
        var dueAt: Date? = null

        @field:NotNull
        var interval: Long? = null
        var intervalType: IntervalType? = null
        var recursFirstOn: Date? = null

        @field:NotNull
        var schemaId: UUID? = null

        var userIds: List<UUID> = emptyList()
    }

    class UpdateReviewMasterForm {
        @field:NotNull
        var id: UUID? = null

        var name: String? = null
        var description: String? = null
        var periodStart: Date? = null
        var periodEnd: Date? = null
        var dueAt: Date? = null
        var interval: Long? = null
        var intervalType: IntervalType? = null
        var recursFirstOn: Date? = null
        var status: StatusType? = null

        var userIds: List<UUID>? = null
        var teamIds: List<UUID>? = null
    }

    class GetReviewMasterResponse(val reviewMaster: ReviewMaster,
                                  val schema: ReviewSchema?,
                                  val reviewedUsers: Set<User>,
                                  val teams: Set<Team>,
                                  val reviews: Set<Review>)

    class TriggerReminderForm {
        @field:NotNull
        var id: UUID? = null

        var userId: UUID? = null
    }
}